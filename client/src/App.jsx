// Imports first! React hooks (useState, useEffect, useCallback, useRef), flushSync for our resize fix, components, and styles!
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { flushSync } from 'react-dom'; // Needed for the resize consistency fix.
import Sidebar from './components/Sidebar'; // Our trusty Sidebar component.
import ContentDisplay from './components/ContentDisplay'; // Where the stuff shows up.
import UploadModal from './components/UploadModal'; // The popup modal for uploads.
import './App.css'; // Styles, including dark mode. Very important.

// --- !!! MOCK DATA FOR UI TESTING (Updated Structure w/ structuredResources) !!! ---
// Expanded structure to demonstrate scrolling! Whoa, lots of classes! 📚
const mockStructureData = {
  "Computer Science": {
    "CS 101 - Intro": { "Course Overview": {}, "Basic Syntax": {}, "Variables & Types": {}, "Control Flow": {}, "Functions": {} },
    "CS 202 - Data Structures": { "Arrays": {}, "Linked Lists": {}, "Stacks & Queues": {}, "Hash Tables": {}, "Trees": {}, "Graphs": {} },
    "CS 303 - Algorithms": { "Big O Notation": {}, "Sorting Algorithms": {}, "Searching Algorithms": {}, "Dynamic Programming": {}, "Greedy Algorithms": {} },
    "CS 404 - Web Dev": { "HTML & CSS": {}, "JavaScript Basics": {}, "React Intro": {}, "Node.js & Express": {} }
  },
  "History": {
    "HIST 110 - US History": { "Colonial Period": {}, "Revolutionary War": {}, "Early Republic": {}, "Civil War": {}, "Reconstruction": {}, "Industrial Age": {} },
    "HIST 320 - WWII": { "Causes": {}, "Rise of Fascism": {}, "European Theater": {}, "Pacific Theater": {}, "The Holocaust": {}, "Aftermath": {} },
    "HIST 250 - Ancient Civ": { "Mesopotamia": {}, "Ancient Egypt": {}, "Ancient Greece": {}, "Roman Republic": {}, "Roman Empire": {} }
  },
  "Biology": {
    "BIO 101 - General Bio": { "Scientific Method": {}, "Cell Structure": {}, "Macromolecules": {}, "Metabolism Intro": {}, "Mitochondria": {}, "Photosynthesis": {}, "Cellular Respiration": {} },
    "BIO 220 - Genetics": { "Mendelian Genetics": {}, "DNA Structure": {}, "Replication & Transcription": {}, "Translation": {}, "Population Genetics": {} },
    "BIO 330 - Ecology": { "Ecosystems": {}, "Biomes": {}, "Population Dynamics": {}, "Community Interactions": {}, "Conservation Biology": {} }
  },
  "Physics": {
      "PHYS 101 - Mechanics": { "Kinematics": {}, "Newton's Laws": {}, "Work & Energy": {}, "Momentum": {}, "Rotational Motion": {} },
      "PHYS 202 - E&M": { "Electric Fields": {}, "Gauss's Law": {}, "Electric Potential": {}, "Capacitance": {}, "Circuits (DC)": {}, "Magnetic Fields": {} }
  },
   "Literature": {
        "LIT 100 - Intro to Lit": { "Poetry Analysis": {}, "Short Stories": {}, "The Novel": {}, "Drama": {} },
        "LIT 340 - Shakespeare": { "Hamlet": {}, "Macbeth": {}, "Romeo & Juliet": {}, "Sonnets": {} }
    },
    "Economics": {
        "ECON 101 - Microeconomics": { "Supply and Demand": {}, "Elasticity": {}, "Market Structures": {}, "Consumer Theory": {} },
        "ECON 102 - Macroeconomics": { "GDP & Inflation": {}, "Aggregate Demand/Supply": {}, "Monetary Policy": {}, "Fiscal Policy": {} }
    }
};

// Updated mock content data with the new 'structuredResources' field!
// Matches: Subject="Computer Science", Class="CS 202 - Data Structures", Topic="Linked Lists"
const mockContentData = [
  {
    uploadDate: "2024-03-10T10:00:00Z", // ISO format is good practice
    topicsCovered: ["Singly Linked Lists", "Node Structure", "Head Pointer", "Traversal"], // Keep this for reference maybe
    summary: "Introduced the fundamental concepts of singly linked lists, including node creation, head pointers, and basic list traversal.",
    // resources: "Legacy text resource field (optional fallback)", // Keep or remove old field
    structuredResources: [ // <-- The NEW structured data! Matches topicsCovered ideally.
      {
        "topic": "Singly Linked Lists",
        "googleLink": "https://www.geeksforgeeks.org/linked-list-set-1-introduction/", // Generated by backend
        "youtubeLink": "https://www.youtube.com/watch?v=njTh_OvY_zo" // Generated by backend
      },
      {
        "topic": "Node Structure",
        "googleLink": "https://en.wikipedia.org/wiki/Node_(computer_science)",
        "youtubeLink": "https://www.youtube.com/watch?v=3_w_mdPyDmY" // Example video
      },
      {
        "topic": "Head Pointer",
        "googleLink": null, // Example: Backend couldn't find a good article
        "youtubeLink": "https://www.youtube.com/watch?v=FtlF4_XG5Ew" // Example video
      },
      {
        "topic": "Traversal",
        "googleLink": "https://www.programiz.com/dsa/linked-list-traversal",
        "youtubeLink": null // Example: Backend couldn't find a good video
      }
    ],
    transcript: "Alright class, today we're moving on to a fundamental data structure: the linked list... (Imagine more transcript text here...)"
  },
  // Second note entry... let's add mock structured data here too
  {
    uploadDate: "2024-03-12T11:30:00Z",
    topicsCovered: ["Insertion (Head, Tail, Middle)", "Deletion"],
    summary: "Covered various insertion methods and how to handle node deletion.",
    structuredResources: [
       {
        "topic": "Insertion", // Maybe backend groups them? Or separate entries? Depends on backend.
        "googleLink": "https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/",
        "youtubeLink": "https://www.youtube.com/watch?v=SCDGNqOx4iA"
      },
       {
        "topic": "Deletion",
        "googleLink": "https://www.geeksforgeeks.org/linked-list-set-3-deleting-node/",
        "youtubeLink": "https://www.youtube.com/watch?v=HAN_N4IIw0Y"
      }
    ],
    transcript: "Okay, building on our previous lecture, let's talk about modifying..."
  }
];
// --- !!! END MOCK DATA !!! ---


// === App Component === The main coordinator, keeping track of everything! ===
function App() {
  // --- State Definitions (Theme, Modal, Resizing - Unchanged) ---
  const [theme, setTheme] = useState('dark');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280);
  const [isResizing, setIsResizing] = useState(false);
  const isResizingRef = useRef(isResizing); // Ref mirrors state for reliable listener checks
  useEffect(() => { isResizingRef.current = isResizing; }, [isResizing]); // Keep ref synced
  const appContainerRef = useRef(null);
  const sidebarRef = useRef(null);

  // --- Core Application State --- Initialize with Mock Data! ---
  // *** Uses the expanded mockStructureData now! ***
  const [folderStructure, setFolderStructure] = useState(mockStructureData);
  // Selection and Content start null as usual.
  const [selectedItem, setSelectedItem] = useState(null); // e.g., { subject: '...', class: '...', topic: '...' } or null
  // *** Current content still expects an ARRAY of note objects *** (which now contain structuredResources)
  const [currentContent, setCurrentContent] = useState(null); // Array of note objects or null
  // Loading and error states still useful, though fetch is bypassed.
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  // --- End Core State ---


  // --- Theme Management Logic --- (Unchanged) ---
  useEffect(() => { /* ... initial theme check ... */ }, []);
  useEffect(() => { document.body.classList.toggle('dark-mode', theme === 'dark'); try {localStorage.setItem('lectureAppTheme', theme);} catch(e){} }, [theme]);
  const toggleTheme = useCallback(() => { setTheme(prev => (prev === 'light' ? 'dark' : 'light')); }, []);
  // --- End Theme Logic ---


  // --- Modal Logic --- (Unchanged) ---
  const openModal = useCallback(() => { setIsModalOpen(true); }, []);
  const closeModal = useCallback(() => { setIsModalOpen(false); }, []);
  // --- End Modal Logic ---


  // --- Resizing Logic --- (Unchanged - persistent listeners approach) ---
  const handleMouseMove = useCallback((e) => { if(!isResizingRef.current) return; let nw=e.clientX; nw=Math.max(200,Math.min(600,nw)); setSidebarWidth(nw);}, []);
  const handleMouseUp = useCallback(() => { if(isResizingRef.current){setIsResizing(false); document.body.style.userSelect=''; document.body.style.cursor='';}}, []);
  useEffect(() => { window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); }; }, [handleMouseMove, handleMouseUp]);
  const handleMouseDown = useCallback((e) => { e.preventDefault(); flushSync(() => { setIsResizing(true); }); document.body.style.userSelect='none'; document.body.style.cursor='col-resize';}, []);
  // --- End Resizing Logic ---


  // --- Data Fetching & Topic Selection Logic --- *** USING MOCK DATA *** ---

  // Fetch folder structure function - Not called initially, uses mock data.
  // Still needed for the onUploadSuccess callback from the modal though!
  const fetchStructure = useCallback(async () => {
    console.log("Fetching/Refreshing structure... (MOCK DATA ACTIVE - won't hit API)");
    setIsLoading(true); setError(null);
    await new Promise(resolve => setTimeout(resolve, 100)); // Simulate tiny delay
    // In a real scenario, you'd fetch updated data. Here, maybe just log.
    // setFolderStructure(someUpdatedMockIfNeeded);
    setIsLoading(false);
    }, []);

  // Initial fetch on mount - *** COMMENTED OUT *** to use mock data right away.
  useEffect(() => {
    console.log("App mounted. Using mock structure data.");
    // fetchStructure(); // <-- BYPASSING fetch on initial load!
  }, []); // Empty deps still means runs once.

  // Fetch content effect - *** USES MOCK DATA *** based on selected item.
  useEffect(() => {
    console.log("Selection changed:", selectedItem); // Log selection changes

    // If nothing is selected (no topic chosen), clear the content.
    if (!selectedItem || !selectedItem.subject || !selectedItem.class || !selectedItem.topic) {
      setCurrentContent(null); // Clear content if selection is incomplete or null
      console.log("Selection incomplete/null, content cleared.");
      return; // Stop here!
    }

    // --- BYPASS API FETCH - USE MOCK DATA INSTEAD ---
    console.log("Bypassing API fetch. Checking mock data for selected item...");
    setIsLoading(true); // Still simulate loading briefly
    setError(null); // Clear errors

    // Check if the selected item matches the key for our mock content data
    if (
      selectedItem.subject === "Computer Science" &&
      selectedItem.class === "CS 202 - Data Structures" &&
      selectedItem.topic === "Linked Lists"
    ) {
      // Match found! Use the mock data array.
      console.log("Selected item matches mock data key! Setting mock content.");
      // Simulate network delay
      setTimeout(() => {
          setCurrentContent(mockContentData);
          setIsLoading(false);
      }, 300); // 300ms delay
    } else {
      // No match for mock data. Show empty state or specific message.
      console.log("Selected item does NOT match mock data key. Setting content to empty array.");
       // Simulate network delay
       setTimeout(() => {
           setCurrentContent([]); // Set to empty array to trigger the "No notes found" message in ContentDisplay
           setIsLoading(false);
       }, 300); // 300ms delay
    }
    // --- End of bypassed fetch logic ---

  }, [selectedItem]); // Dependency: run when selectedItem (with all 3 levels) changes!


  // Handle topic clicks from Sidebar - (Unchanged - still sets the 3-level selectedItem state).
  const handleSelectTopic = useCallback((subject, className, topic) => {
    console.log(`Topic selected: ${subject}/${className}/${topic}`);
    const newItem = { subject, class: className, topic };
    if (selectedItem?.subject !== subject || selectedItem?.class !== className || selectedItem?.topic !== topic) {
      setSelectedItem(newItem); // Update the state with the new 3-level selection!
    } else {
      console.log("...same topic selected.");
    }
  }, [selectedItem]); // Depends on selectedItem to check against current.
  // --- End Data/Selection Logic ---


  // --- THE RENDERED JSX --- What the user actually sees! ---
  return (
    // Fragment because Modal & Theme Button are outside the main layout div.
    <>
      {/* Main app layout container */}
      <div className="app-container" ref={appContainerRef}>

        {/* Sidebar Component - Renders the expanded mockStructureData */}
        <Sidebar
          ref={sidebarRef}
          style={{ width: `${sidebarWidth}px` }}
          structure={folderStructure} // Pass the initial mock structure
          onSelectTopic={handleSelectTopic} // Pass the selection handler
          selectedItem={selectedItem} // Pass current selection state
          onResizeMouseDown={handleMouseDown} // Pass resize handler
          onOpenUploadModal={openModal} // Pass modal opener
        />

        {/* Content Display Component - Renders mockContentData or empty */}
        {/* This will now look for 'structuredResources' within the content array */}
        <ContentDisplay
          content={currentContent} // Pass the content array (mock or empty)
          selectedItem={selectedItem} // Pass selection info
          isLoading={isLoading} // Pass loading state
          error={error} // Pass error state
        />

      </div> {/* End app-container */}


      {/* Theme Toggle Button - Unchanged */}
      <button
        onClick={toggleTheme}
        className="theme-toggle-button"
        aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
        title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
      >
        {theme === 'light' ? '🌙' : '☀️'}
      </button>

      {/* Upload Modal - Opens, but upload won't hit backend. Success callback is mock-aware. */}
      <UploadModal
        isOpen={isModalOpen}
        onClose={closeModal}
        onUploadSuccess={fetchStructure} // Refresh callback remains the same name, just mock logic inside.
      />

    </> // End React Fragment
  ); // End return
} // End App component

// Export App!
export default App;
